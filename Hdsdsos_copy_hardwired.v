// -------------------------------------------------------------
//
// Module: Hdsdsos_copy_hardwired
//
// Generated by MATLAB(R) 7.12 and the Filter Design HDL Coder 2.8.
//
// Generated on: 2013-03-12 03:07:26
//
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Code Generation Options:
//
// ResetType: Synchronous
// OptimizeForHDL: on
// EDAScriptGeneration: off
// Name: Hdsdsos_copy_hardwired
// TargetLanguage: Verilog
// TestBenchName: Hdsdsos_copy_tb
// TestBenchStimulus: 
// GenerateHDLTestBench: off

// -------------------------------------------------------------
// HDL Implementation    : Fully parallel
// -------------------------------------------------------------
// Filter Settings:
//
// Discrete-Time IIR Filter (real)
// -------------------------------
// Filter Structure    : Direct-Form II Transposed, Second-Order Sections
// Number of Sections  : 1
// Stable              : Yes
// Linear Phase        : No
// Arithmetic          : fixed
// Numerator           : s18,16 -> [-2 2)
// Denominator         : s18,16 -> [-2 2)
// Scale Values        : s18,17 -> [-1 1)
// Input               : s16,0 -> [-32768 32768)
// Section Input       : s16,0 -> [-32768 32768)
// Section Output      : s18,0 -> [-131072 131072)
// Output              : s16,0 -> [-32768 32768)
// State               : s18,2 -> [-32768 32768)
// Numerator Prod      : s36,16 -> [-524288 524288)
// Denominator Prod    : s36,16 -> [-524288 524288)
// Numerator Accum     : s18,1 -> [-65536 65536)
// Denominator Accum   : s18,1 -> [-65536 65536)
// Round Mode          : convergent
// Overflow Mode       : wrap
// Cast Before Sum     : true
// -------------------------------------------------------------
`timescale 1 ns / 1 ns

module Hdsdsos_copy_hardwired
               (
                clk,
                clk_enable,
                reset,
                filter_in,
                filter_out
                );

  input   clk; 
  input   clk_enable; 
  input   reset; 
  input   signed [15:0] filter_in; //sfix16
  output  signed [15:0] filter_out; //sfix16

////////////////////////////////////////////////////////////////
//Module Architecture: Hdsdsos_copy_hardwired
////////////////////////////////////////////////////////////////
  // Local Functions
  // Type Definitions
  // Constants
  parameter signed [17:0] coeff_b1_section1 = 18'b010000000000000000; //sfix18_En16
  parameter signed [17:0] coeff_b2_section1 = 18'b100000010100110000; //sfix18_En16
  parameter signed [17:0] coeff_b3_section1 = 18'b010000000000000000; //sfix18_En16
  parameter signed [17:0] coeff_a2_section1 = 18'b100000011000110100; //sfix18_En16
  parameter signed [17:0] coeff_a3_section1 = 18'b001111111011111010; //sfix18_En16
  // Signals
  reg  signed [15:0] input_register; // sfix16
  // Section 1 Signals 
  wire signed [17:0] ab1sum1; // sfix18_En1
  wire signed [17:0] ab2sum1; // sfix18_En1
  wire signed [17:0] ab3sum1; // sfix18_En1
  wire signed [17:0] b2sum1; // sfix18_En1
  reg  signed [17:0] delay1_section1; // sfix18_En2
  reg  signed [17:0] delay2_section1; // sfix18_En2
  wire signed [15:0] inputconv1; // sfix16
  wire signed [17:0] feedback1; // sfix18
  wire signed [35:0] a2mul1; // sfix36_En16
  wire signed [35:0] a3mul1; // sfix36_En16
  wire signed [35:0] b2mul1; // sfix36_En16
  wire signed [33:0] mul_temp; // sfix34_En16
  wire signed [17:0] sub_cast; // sfix18_En1
  wire signed [17:0] sub_cast_1; // sfix18_En1
  wire signed [18:0] sub_temp; // sfix19_En1
  wire signed [17:0] add_cast; // sfix18_En1
  wire signed [17:0] add_cast_1; // sfix18_En1
  wire signed [18:0] add_temp; // sfix19_En1
  wire signed [17:0] sub_cast_2; // sfix18_En1
  wire signed [17:0] sub_cast_3; // sfix18_En1
  wire signed [18:0] sub_temp_1; // sfix19_En1
  wire signed [17:0] add_cast_2; // sfix18_En1
  wire signed [17:0] add_cast_3; // sfix18_En1
  wire signed [18:0] add_temp_1; // sfix19_En1
  wire signed [17:0] delay1_typeconvert1; // sfix18_En2
  wire signed [17:0] delay2_typeconvert1; // sfix18_En2
  wire signed [15:0] output_typeconvert; // sfix16
  reg  signed [15:0] output_register; // sfix16

  // Block Statements
  always @ ( posedge clk)
    begin: input_reg_process
      if (reset == 1'b1) begin
        input_register <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          input_register <= filter_in;
        end
      end
    end // input_reg_process

  // ------------------ Section 1 ------------------

  assign inputconv1 = input_register;

  assign a2mul1 = feedback1 * coeff_a2_section1;

  assign a3mul1 = feedback1 * coeff_a3_section1;

  assign mul_temp = inputconv1 * coeff_b2_section1;
  assign b2mul1 = $signed({{2{mul_temp[33]}}, mul_temp});

  assign sub_cast = $signed({inputconv1[15:0], 1'b0});
  assign sub_cast_1 = (a3mul1[32:0] + {a3mul1[15], {14{~a3mul1[15]}}})>>>15;
  assign sub_temp = sub_cast - sub_cast_1;
  assign ab3sum1 = sub_temp[17:0];

  assign add_cast = (b2mul1[32:0] + {b2mul1[15], {14{~b2mul1[15]}}})>>>15;
  assign add_cast_1 = ({{1{delay2_section1[17]}}, delay2_section1[17:0]} + delay2_section1[1])>>>1;
  assign add_temp = add_cast + add_cast_1;
  assign b2sum1 = add_temp[17:0];

  assign sub_cast_2 = b2sum1;
  assign sub_cast_3 = (a2mul1[32:0] + {a2mul1[15], {14{~a2mul1[15]}}})>>>15;
  assign sub_temp_1 = sub_cast_2 - sub_cast_3;
  assign ab2sum1 = sub_temp_1[17:0];

  assign add_cast_2 = ({{1{delay1_section1[17]}}, delay1_section1[17:0]} + delay1_section1[1])>>>1;
  assign add_cast_3 = $signed({inputconv1[15:0], 1'b0});
  assign add_temp_1 = add_cast_2 + add_cast_3;
  assign ab1sum1 = add_temp_1[17:0];

  assign delay1_typeconvert1 = $signed({ab2sum1[16:0], 1'b0});

  assign delay2_typeconvert1 = $signed({ab3sum1[16:0], 1'b0});

  always @ ( posedge clk)
    begin: delay_process_section1
      if (reset == 1'b1) begin
        delay1_section1 <= 0;
        delay2_section1 <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay1_section1 <= delay1_typeconvert1;
          delay2_section1 <= delay2_typeconvert1;
        end
      end
    end // delay_process_section1

  assign feedback1 = ({{1{ab1sum1[17]}}, ab1sum1[17:0]} + ab1sum1[1])>>>1;

  assign output_typeconvert = feedback1[15:0];

  always @ ( posedge clk)
    begin: Output_Register_process
      if (reset == 1'b1) begin
        output_register <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          output_register <= output_typeconvert;
        end
      end
    end // Output_Register_process

  // Assignment Statements
  assign filter_out = output_register;
endmodule  // Hdsdsos_copy_hardwired
